<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="計算で加速！走り続ける脳トレアクションゲーム - 計算疾走！RUN×算">
  <title>計算疾走！RUN×算</title>
  <link rel="stylesheet" href="style.css">
</head><style>
    body { 
        font-family: sans-serif; 
        background: #eef; 
        text-align: center; 
        margin: 0; 
        /* ゲーム全体が画面中央に配置されるように調整 */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh; /* 画面全体の高さに合わせる */
        overflow: hidden; /* スクロールを完全に防ぐ */
    }

    /* タイトル画面 */
    #title-screen {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw; /* 画面全体に広げる */
        background-color: #e0f7fa;
        position: fixed; /* 常に画面全体を覆う */
        top: 0;
        left: 0;
        z-index: 2000; /* 最前面に表示 */
    }
    #title-screen h1 {
        font-size: 6vw; /* 画面幅に合わせて調整 */
        color: #333;
    }
    #start-button, #adult-mode-button {
        margin-top: 2.5vh; /* 画面高さに合わせて調整 */
        padding: 2vh 4vw; /* 画面サイズに合わせて調整 */
        font-size: 2.5vw; /* 画面幅に合わせて調整 */
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 1vw;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    #adult-mode-button {
        background-color: #f44336;
    }
    #start-button:hover, #adult-mode-button:hover {
        background-color: #45a049;
    }
    #ranking-list {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding-left: 0;
        list-style: none;
    }
    #ranking-list li {
        margin: 0.8vh 0; /* 画面高さに合わせて調整 */
        font-size: 2vw; /* 画面幅に合わせて調整 */
        font-weight: bold;
        color: #333;
    }
    #ranking-modal button {
        margin-top: 2.5vh; /* 画面高さに合わせて調整 */
        padding: 1.5vh 3vw; /* 画面サイズに合わせて調整 */
        font-size: 2.2vw; /* 画面幅に合わせて調整 */
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 1vw;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    #ranking-modal button:hover {
        background: #45a049;
    }

    /* ★ゲーム本体の画面調整★ */
    #game {
        position: relative;
        /* 元の比率 800:300 を維持 */
        aspect-ratio: 8 / 3; 
        /* 画面幅の90%を使用し、最大の幅を800pxに制限 */
        width: 90vw; 
        max-width: 800px; /* PCなどでの上限 */
        
        background: url('上空.jpg') repeat-x center center;
        background-size: cover;
        border: 0.25vw solid #000; /* borderもvwで */
        margin: 20px auto; /* 中央寄せ */
        overflow: hidden;
        background-position: 0 0;
        
        /* ゲームが非表示の時は見えないように */
        display: none; 
    }

    #game.fade {
        transition: opacity 0.3s ease;
        opacity: 0;
    }
    
    /* UI要素の調整 */
    h1 { /* 「↑↑でレーン移動！ →で加速」のh1 */
        font-size: 3vw; 
        margin-top: 1vh;
        margin-bottom: 1vh;
    }
    #question {
        font-size: 3vw; 
        margin-top: 1vh;
        margin-bottom: 1vh;
    }
    #target {
        font-size: 4.5vw; 
        color: #d32f2f;
        font-weight: bold;
        padding: 0 1vw;
        border-radius: 0.5vw;
    }
    #distance {
        font-size: 2.5vw; 
        margin-top: 0.5vh;
        margin-bottom: 0.5vh;
    }
    #lives {
        height: 5vh; /* 表示中のハートの高さくらいに合わせる */
        font-size: 3.5vw;
        line-height: 5vh;
        margin-top: 0.5vh;
        margin-bottom: 0.5vh;
    }
    
    .lane {
        position: absolute; 
        width: 100%; 
        height: 33.33%; /* #gameの高さの1/3 */
        border-top: 0.1vw solid #ccc; /* borderもvwで */
    }
    /* レーンの配置を微調整 */
    .lane:nth-child(1) { top: 0; }
    .lane:nth-child(2) { top: 33.33%; }
    .lane:nth-child(3) { top: 66.66%; }


    /* ★プレイヤーの調整★ */
    #player {
        position: absolute; 
        /* 50px / 800px = 6.25% → 6.25vw (ゲーム画面の幅の6.25%) */
        left: 6.25%; 
        /* 50px / 300px = 16.66...% → 16.67% (ゲーム画面の高さの16.67%) */
        width: 6.25%; 
        height: 16.67%; 
        background: url('type_zero_anf.gif') no-repeat center center;
        background-size: 90%; 
        transition: top 0.1s;
    }

    /* ★障害物の調整★ */
    .obstacle {
        position: absolute;
        /* 100px / 800px = 12.5% → 12.5% (ゲーム画面の幅の12.5%) */
        width: 12.5%; 
        /* 50px / 300px = 16.66...% → 16.67% (ゲーム画面の高さの16.67%) */
        height: 16.67%; 
        background: rgba(173, 216, 230, 0.85); 
        /* フォントサイズも画面幅に合わせて調整 */
        font-size: 2.75vw; /* 元の22pxをvwに変換 (22/800 * 100vw = 2.75vw) */
        text-align: center;
        line-height: 100%; /* 親要素(obstacle)の高さに対して中央 */
        font-weight: bold;
        font-family: "Consolas", "Courier New", monospace;
        transform: translateZ(0);
        will-change: transform;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
        border: 0.25vw solid #007acc; /* borderもvwに */
        border-radius: 1vw; /* border-radiusもvwに */
        box-shadow: 0.25vw 0.25vw 0.75vw rgba(0, 0, 0, 0.3); /* 影もvwに */
        color: #fff;
        text-shadow: 0.125vw 0.125vw 0.25vw #000; /* 文字影もvwに */
    }

    /* コンボゲージ */
    #combo-bar-container {
        width: 37.5vw; /* 300px / 800px = 37.5% → 37.5vw */
        max-width: 300px; /* 最大幅も設定 */
        height: 3.125vh; /* 25px / 300px (高さ) = 8.33% → 約3.125vh (25 / 800 * 100 = 3.125) */
        background-color: #ccc;
        border-radius: 1.5vw;
        margin: 1.5vh auto;
        overflow: hidden;
        border: 0.25vw solid #333;
    }

    #combo-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4CAF50, #8BC34A);
        transition: width 0.2s ease;
    }
    
    /* ランキングモーダル */
    #ranking-modal {
        display:none; 
        position:fixed; 
        top:50%; 
        left:50%; 
        transform:translate(-50%,-50%);
        background:white; 
        padding: 4vh 4vw; /* 画面サイズに合わせて調整 */
        border:0.25vw solid #000; 
        border-radius:2vw; 
        z-index:1000;
        width: 70vw; /* モーダルの幅も調整 */
        max-width: 400px;
    }
    #ranking-modal h2 {
        font-size: 4vw; /* 画面幅に合わせて調整 */
        margin-bottom: 2vh;
    }
    #ranking-modal p, #ranking-modal h3 {
        font-size: 2.5vw; /* 画面幅に合わせて調整 */
        margin-bottom: 1vh;
    }
    #ranking-modal ol {
        font-size: 2vw; /* 画面幅に合わせて調整 */
    }

    /* スキン選択 */
    #skin-select p {
        font-size: 2.5vw;
    }
    #skin-select div {
        gap: 1vw; /* 隙間もvwで */
    }
    .skin-option {
        width: 6vw; /* 5vwから少し調整 */
        height: 6vw;
        cursor:pointer; 
        border:0.25vw solid transparent; /* borderもvwに */
        border-radius:1vw; /* border-radiusもvwに */
    }
    .skin-option:hover {
        border-color: #4CAF50; /* ホバー時の色 */
    }
</style>
<body>

    <!-- タイトル画面 -->
    <div id="title-screen">
        <h1>計算疾走！RUN×算</h1>
        <button id="start-button">ゲームスタート</button>
        <button id="adult-mode-button" style="margin-top: 10px; padding: 15px 30px; font-size: 20px; background-color: #f44336; color: white; border: none; border-radius: 10px; cursor: pointer; transition: background-color 0.3s;">オトナモード</button>
        <!-- スキン選択モーダル -->
        <div id="skin-select" style="margin-top: 20px;">
            <p style="font-size: 20px;">スキンを選ぼう！</p>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <img src="type_zero_anf.gif" class="skin-option" onclick="selectSkin('type_zero_anf.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="fighter_3body_an.gif" class="skin-option" onclick="selectSkin('fighter_3body_an.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="fighter_f104_an.gif" class="skin-option" onclick="selectSkin('fighter_f104_an.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="type_zero21_anf.gif" class="skin-option" onclick="selectSkin('type_zero21_anf.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="helicopter_2.gif" class="skin-option" onclick="selectSkin('helicopter_2.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="bird18.gif" class="skin-option" onclick="selectSkin('bird18.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="karasu.gif" class="skin-option" onclick="selectSkin('karasu.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="chiken.gif" class="skin-option" onclick="selectSkin('chiken.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="dog.gif" class="skin-option" onclick="selectSkin('dog.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="angel.gif" class="skin-option" onclick="selectSkin('angel.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
                <img src="ufo.gif" class="skin-option" onclick="selectSkin('ufo.gif')" style="width:5vw; height:5vw; cursor:pointer; border:2px solid transparent; border-radius:10px;">
            </div>
        </div>
    </div>
    
<!-- BGMとSEをここにまとめて配置 -->
<audio id="bgm" src="8ビットの冒険.mp3" loop></audio>
<audio id="se-correct" src="決定ボタンを押す53.mp3"></audio>
<audio id="se-wrong" src="ビープ音4.mp3"></audio>

<h1>↑↑でレーン移動！　→で加速</h1>
<!-- <h2>→で加速</h2> -->
<div id="question">答えが <span id="target">?</span> になる式を選ぼう！</div>
<div id="distance" style="font-size: 18px; margin-top: 5px;">00000m</div>
<div id="lives">❤️❤️❤️</div>
<div id="combo-bar-container">
    <div id="combo-bar"></div>
</div>
<div id="game">
    <div id="player"></div>
    <div id="ranking-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
        background:white; padding:30px; border:2px solid #000; border-radius:20px; z-index:1000;">
        <h2>🏁 GAME OVER！</h2>
        <p id="final-score">あなたのスコア: 0</p>
        <h3>🏆 ランキング</h3>
        <ol id="ranking-list" style="text-align:left; padding-left: 20px;"></ol>
        <button onclick="restartGame()">リトライ</button>
        <button onclick="returnToTitle()">タイトル画面に戻る</button>
    </div>
</div>


<!-- 背景ぼかし用 -->
<div id="overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.5); z-index:1000;"></div>

<script>
const game = document.getElementById("game");
const player = document.getElementById("player");
const targetSpan = document.getElementById("target");
const livesDisplay = document.getElementById("lives");

const bgm = document.getElementById("bgm");
const seCorrect = document.getElementById("se-correct");
const seWrong = document.getElementById("se-wrong");

const lanes = [0, 0, 0]; // Y座標
const backgrounds = [
    "上空.jpg", "夕方.jpg", "夜.jpg"
];
let backgroundIndex = 0;
let currentLane = 1;
let score = 0;
let targetAnswer = 0;
let lives = 3;
let isSpawning = false;
let hasAnswered = false;
let started = false; // BGM再生フラグ
// ▼ 背景スクロール
let bgPos = 0;
let distance = 0; // 移動距離
setInterval(() => {
    // 背景移動
    bgPos -= speed / 2;
    game.style.backgroundPosition = `${bgPos}px 0`;

    // 距離加算（speedに比例）
    distance += speed  * 0.01;
    const formattedDistance = Math.floor(distance).toString().padStart(5, '0') + 'm';
    document.getElementById('distance').textContent = formattedDistance;

}, 20);

let selectedSkin = 'type_zero_anf.gif'; // デフォルト
function selectSkin(skinFile) {
    selectedSkin = skinFile;
    player.style.backgroundImage = `url('${selectedSkin}')`;

    // 全部リセットしてから選んだやつだけ枠線つける
    document.querySelectorAll('.skin-option').forEach(img => {
        img.style.border = '2px solid transparent';
    });
    const selectedImg = Array.from(document.querySelectorAll('.skin-option')).find(img => img.src.includes(skinFile));
    if (selectedImg) {
        selectedImg.style.border = '2px solid #4CAF50';
    }
}

player.style.top = lanes[currentLane] + "px";

// ゲームの初期速度
const INITIAL_GAME_SPEED = 2; 
let speed = INITIAL_GAME_SPEED; // 現在のゲーム速度 (実際に障害物の移動に使われる変数)
let baseGameSpeed = INITIAL_GAME_SPEED; // スコアに応じて永続的に変化する「基準」となるゲーム速度

// BGMの初期再生レート
const INITIAL_BGM_PLAYBACK_RATE = 1.0; 
let currentBaseBGMPlaybackRate = INITIAL_BGM_PLAYBACK_RATE; // スコアに応じて永続的に変化するBGMの基準レート

let isAccelerating = false; // 加速中かどうかのフラグ

let touchStartY = 0; // タッチ開始時のY座標を保存
let touchStartX = 0; // タッチ開始時のX座標を保存
const SWIPE_THRESHOLD = 50; // スワイプと認識するための最低ピクセル距離

// ゲームの初期化時に一度だけ呼ばれる関数
function initializeGameLayout() {
    updateLanePositions(); // レーンの位置を初期化
    player.style.backgroundImage = `url('${selectedSkin}')`; // プレイヤーのスキンを初期設定
}

// ゲーム画面の要素を取得
const gameArea = document.getElementById("game");

// レーンの位置を動的に計算する関数
function updateLanePositions() {
    const gameHeight = gameArea.offsetHeight; // #game要素の現在の高さを取得

    // 元の25px, 125px, 225px は高さ300pxのゲーム画面での値
    // 例えば、上から25pxは 25/300 = 約8.33%
    // これを現在のゲーム画面の高さに適用する
    lanes[0] = gameHeight * (25 / 300); // 最上レーンのY座標
    lanes[1] = gameHeight * (125 / 300); // 中央レーンのY座標
    lanes[2] = gameHeight * (225 / 300); // 最下レーンのY座標

    // プレイヤーの現在のレーン位置を更新
    player.style.top = lanes[currentLane] + "px"; 
}

// gameAreaが存在する場合のみイベントリスナーを設定
if (gameArea) {
    let touchStartY = 0; // タッチ開始時のY座標を保存
    let touchStartX = 0; // タッチ開始時のX座標を保存
    const SWIPE_THRESHOLD = 50; // スワイプと認識するための最低ピクセル距離

    // タッチ開始時のイベントリスナー
    gameArea.addEventListener("touchstart", (e) => {
        touchStartY = e.touches[0].clientY;
        touchStartX = e.touches[0].clientX;

        // BGM再生開始ロジックも、ゲームエリアでの最初のタッチに合わせる
        if (!started) {
            bgm.volume = 0.1;
            bgm.play().catch(error => console.log("BGM再生失敗", error));
            started = true;
            bgm.playbackRate = INITIAL_BGM_PLAYBACK_RATE;
        }
        // ここでは e.preventDefault() は不要 (touchmove で行うため)
    }, { passive: true });

    // タッチ移動時のイベントリスナー
    gameArea.addEventListener("touchmove", (e) => {
        // ★ここが重要★：ゲーム画面上でのスワイプによるブラウザのデフォルトスクロール動作を停止
        e.preventDefault(); 
    }, { passive: false }); // preventDefault() を使うので passive は false にする

    // タッチ終了時のイベントリスナー
    gameArea.addEventListener("touchend", (e) => {
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndX = e.changedTouches[0].clientX;

        const deltaY = touchStartY - touchEndY;
        const deltaX = touchEndX - touchStartX;

        // 縦方向のスワイプ（レーン変更）を処理
        if (Math.abs(deltaY) > SWIPE_THRESHOLD && Math.abs(deltaY) > Math.abs(deltaX)) {
            if (deltaY > 0 && currentLane > 0) { // 上へスワイプ
                currentLane--;
                console.log("上にスワイプ！現在のレーン:", currentLane);
            } else if (deltaY < 0 && currentLane < 2) { // 下へスワイプ
                currentLane++;
                console.log("下にスワイプ！現在のレーン:", currentLane);
            }
            player.style.top = lanes[currentLane] + "px";
        }
        // 横方向のスワイプ（加速/減速）を処理
        else if (Math.abs(deltaX) > SWIPE_THRESHOLD && Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > 0 && !isAccelerating) { // 右へスワイプ（加速）
                speed = baseGameSpeed * 2;
                bgm.playbackRate = currentBaseBGMPlaybackRate * 2;
                isAccelerating = true;
                console.log("右にスワイプ！速度2倍！現在の速度:", speed);
                console.log("BGM再生レート2倍！新しいレート:", bgm.playbackRate);
            } else if (deltaX < 0 && isAccelerating) { // 左へスワイプ（減速）
                 speed = baseGameSpeed;
                 bgm.playbackRate = currentBaseBGMPlaybackRate;
                 isAccelerating = false;
                 console.log("左にスワイプ！速度が通常に戻る！現在の速度:", speed);
                 console.log("BGM再生レートが通常に戻る！現在のレート:", bgm.playbackRate);
            }
        }
    });
}

// ▼ ゲーム開始ボタン
document.getElementById("start-button").addEventListener("click", function() {
    document.getElementById("title-screen").style.display = "none";
    game.style.display = "block"; // ゲーム画面を表示
    
    // ゲーム開始時にもレーン位置を更新
    updateLanePositions(); 
    player.style.backgroundImage = `url('${selectedSkin}')`; 
    distance = 0;
    isAdultMode = false;
    spawnChallenge();
});

document.getElementById('adult-mode-button').addEventListener('click', () => {
    document.getElementById("title-screen").style.display = "none";
    game.style.display = "block"; // ゲーム画面を表示

    // ゲーム開始時にもレーン位置を更新
    updateLanePositions();
    player.style.backgroundImage = `url('${selectedSkin}')`; 
    distance = 0;
    isAdultMode = true;
    spawnChallenge();
});

// ▼ 式をランダム生成
function generateExpressions() {
    const ops = ["+", "-", "*", "/"];
    const expressions = [];
    if (isAdultMode){
        const a = Math.floor(Math.random() * 50) + 1;
        const b = Math.floor(Math.random() * 50) + 1;
        const op = ops[Math.floor(Math.random() * ops.length)];
        const expr = `${a}${op}${b}`;
        const answer = eval(expr);
        if (op === "/" && a % b !== 0) return generateExpressions(); // 再生成

        targetAnswer = answer;
        expressions.push(expr);

        while (expressions.length < 3) {
            const a2 = Math.floor(Math.random() * 50) + 1;
            const b2 = Math.floor(Math.random() * 50) + 1;
            const op2 = ops[Math.floor(Math.random() * ops.length)];
            const expr2 = `${a2}${op2}${b2}`;
            let res2;
            try { res2 = eval(expr2); } catch { continue; }
            if (res2 !== targetAnswer && Number.isFinite(res2)) {
                expressions.push(expr2);
            }
        }
    }
    else{
        const a = Math.floor(Math.random() * 9) + 1;
        const b = Math.floor(Math.random() * 9) + 1;
        const op = ops[Math.floor(Math.random() * ops.length)];
        const expr = `${a}${op}${b}`;
        const answer = eval(expr);
        if (op === "/" && a % b !== 0) return generateExpressions(); // 再生成
        
        targetAnswer = answer;
        expressions.push(expr);
        
        while (expressions.length < 3) {
            const a2 = Math.floor(Math.random() * 9) + 1;
            const b2 = Math.floor(Math.random() * 9) + 1;
            const op2 = ops[Math.floor(Math.random() * ops.length)];
            const expr2 = `${a2}${op2}${b2}`;
            let res2;
            try { res2 = eval(expr2); } catch { continue; }
            if (res2 !== targetAnswer && Number.isFinite(res2)) {
                expressions.push(expr2);
            }
        }            
    }
    return expressions.sort(() => Math.random() - 0.5);
}

// ▼ 問題を出す
function spawnChallenge() {
    if (isSpawning) return;
    isSpawning = true;
    hasAnswered = false;

    const expressions = generateExpressions();
    targetSpan.textContent = targetAnswer;

    const correctLane = expressions.findIndex(e => eval(e) === targetAnswer);

    expressions.forEach((expr, i) => {
        const obstacle = document.createElement("div");
        obstacle.className = "obstacle";
        obstacle.textContent = expr.replace('*', 'ｘ').replace('/', '／').replace('+', '＋').replace('-', 'ー');
        
        // obstacle.style.top は lanes[i] で設定されているので変更なし
        obstacle.style.top = lanes[i] + "px"; 
        
        // ★変更点★ 障害物の初期位置（右端）をゲーム画面の幅に合わせる
        obstacle.style.left = game.offsetWidth + "px"; 
        game.appendChild(obstacle);

        let pos = game.offsetWidth; // 初期位置も現在のゲーム画面の幅から開始
        const move = setInterval(() => {
            pos -= speed; 
            obstacle.style.left = pos + "px";

            // ★変更点★ 衝突判定の基準値も現在のゲーム画面のサイズに合わせて調整
            // プレイヤーのleft: 6.25% (game.offsetWidth * 0.0625)
            // プレイヤーのwidth: 6.25% (game.offsetWidth * 0.0625)
            // 障害物のwidth: 12.5% (game.offsetWidth * 0.125)
            const playerVisualLeft = game.offsetWidth * 0.0625; // プレイヤーの表示上の左端
            const playerVisualWidth = game.offsetWidth * 0.0625; // プレイヤーの表示上の幅
            const obstacleVisualWidth = game.offsetWidth * 0.125; // 障害物の表示上の幅


            if (pos < (playerVisualLeft + playerVisualWidth * 0.8) && // プレイヤーの少し手前で判定
                (pos + obstacleVisualWidth * 0.8) > playerVisualLeft && // 障害物の少し手前で判定
                i === currentLane) {
                if (hasAnswered) return;

                hasAnswered = true;
                clearInterval(move);
                game.removeChild(obstacle);

                if (i === correctLane) {
                    score++;
                    combo++;
                    updateComboBar();
                    // 10コンボで❤1回復（ただし最大3つまで）
                    if (combo % 10 === 0 && lives < 3) {
                        lives++;
                        updateHearts();
                        updateLivesDisplay();

                        // 🔥 ゲージが光る演出
                        const bar = document.getElementById("combo-bar");
                        bar.classList.add("combo-flash");
                        setTimeout(() => bar.classList.remove("combo-flash"), 500);
                    }

                    if (score % 2 === 0){
                        // ★ここが主な変更点★
                        // ゲームの「基準となるスピード」を上げる
                        baseGameSpeed += (score <= 6) ? 0.45 : (score <= 14) ? 0.38 : (score < 30) ? 0.15 : 0.1;
                        
                        // BGMの「基準となるレート」を上げる
                        currentBaseBGMPlaybackRate += 0.015;
                        
                        // もし現在加速中でなければ、実際に使用される speed と bgm.playbackRate を基準値に更新
                        // 加速中の場合は、speed と bgm.playbackRate は加速した状態を維持する
                        // キーアップ時に baseGameSpeed と currentBaseBGMPlaybackRate に戻る
                        if (!isAccelerating) {
                            speed = baseGameSpeed; // 実際に障害物移動に使う speed も更新
                            bgm.playbackRate = currentBaseBGMPlaybackRate;
                        }
                    }

                    if (score % 10 === 0) {
                        backgroundIndex = (backgroundIndex + 1) % backgrounds.length;
                        game.style.opacity = 0;
                        
                        // 画像変更を確実に行うために2フレーム待つ
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
                                game.style.opacity = 1;
                            });
                        });
                    }
                    seCorrect.currentTime = 0;
                    seCorrect.volume = 0.5;
                    seCorrect.play();
                }
                else {
                    combo = 0;
                    updateComboBar();

                    lives--;
                    updateLivesDisplay();
                    updateHearts();
                    seWrong.currentTime = 0;
                    seWrong.volume = 0.5;
                    seWrong.play();

                    flashPlayerRed();

                    if (lives <= -1) {
                        fadeOutBGM();
                        if (isAdultMode){
                            const normalRankings = updateRanking(distance, false, selectedSkin);
                            showRanking(normalRankings);
                        }
                        else{
                            const Adultrankings = updateRanking(distance, true, selectedSkin);
                            showRanking(Adultrankings);
                        }
                        return;
                    }
                }
            // 障害物が画面外に出たかどうかの判定も、障害物の幅を考慮して調整
            if (pos < -obstacleVisualWidth) { 
                clearInterval(move);
                if (obstacle.parentNode === game) { 
                    game.removeChild(obstacle);
                }
                // 問題が出現するまでの間隔も current speed に応じて変化
                setTimeout(() => {
                    isSpawning = false;
                    spawnChallenge();
                }, 4 * 1000 / baseGameSpeed); 
            }
        }
        }, 20); // 障害物の移動間隔
    });
}

// ウィンドウのリサイズイベントリスナー
window.addEventListener('resize', () => {
    updateLanePositions(); // 画面サイズ変更時にレーン位置を再計算
    // スキン選択ボタンの幅/高さも再計算されるので、選択中の枠線を再適用
    selectSkin(selectedSkin); // 現在選択中のスキンに再度枠線を適用
});


// 初期ロード時にスキン選択の枠線を設定し、レーン位置を初期化
document.addEventListener('DOMContentLoaded', () => {
    selectSkin(selectedSkin); // デフォルトスキンに枠線を適用
    // initialGameLayout(); // ゲーム画面の初期表示準備はスタートボタンクリック時に行う
});


// ▼ ダメージモーション1
function flashPlayerRed(times = 3, interval = 100) {
    let count = 0;
    const flash = () => {
        player.style.filter = count % 2 === 0 ? "brightness(0.4)" : "none";
        count++;
        if (count < times * 2) {
            setTimeout(flash, interval);
        } else {
            player.style.filter = "none";
        }
    };
    flash();
}

// ▼ ダメージモーション2
function updateLivesDisplay() {
    livesDisplay.innerHTML = `${"❤️".repeat(Math.max(0, lives))}`;
}

// ▼ ランキング保存
function updateRanking(distance, isAdultMode = false, skin = "default") {
    const key = isAdultMode ? "adultRankings" : "normalRankings";
    const data = JSON.parse(localStorage.getItem(key)) || [];

    // 距離とスキンのオブジェクト形式で保存
    data.push({ score: Math.floor(distance), skin: skin });

    // スコア順に並び替え
    data.sort((a, b) => b.score - a.score);

    const topData = data.slice(0, 1000);
    localStorage.setItem(key, JSON.stringify(topData));

    return topData;
}


function updateHearts() {
    const heart = "❤️";
    livesDisplay.textContent = heart.repeat(Math.max(0, lives));
}

function showRanking(rankings) {
    const modal = document.getElementById("ranking-modal");
    const finalScore = document.getElementById("final-score");
    const rankingList = document.getElementById("ranking-list");

    const myScore = Math.floor(distance);
    const myRank = rankings.findIndex(entry => entry.score === myScore) + 1;
    finalScore.textContent = `あなたのスコア: ${myScore}（${myRank}位）`;

    rankingList.innerHTML = "";
    const medals = ["🥇", "🥈", "🥉"];

    rankings.slice(0, 7).forEach((entry, i) => {
        const li = document.createElement("li");

        // テキスト
        const text = document.createElement("span");
        if (i < medals.length) {
            text.textContent = `${medals[i]} ${entry.score}`;
        } else {
            text.textContent = `${i + 1}位: ${entry.score}`;
        }

        // スキン画像
        const img = document.createElement("img");
        img.src = entry.skin || "default.gif"; // 念のため fallback も
        img.alt = "skin";
        img.width = 32;
        img.height = 32;
        img.style.verticalAlign = "middle";
        img.style.marginLeft = "8px";
        img.style.borderRadius = "5px";

        li.appendChild(text);
        li.appendChild(img);
        rankingList.appendChild(li);
    });

    modal.style.display = "block";
}


function restartGame() {
    // スコア・ライフ・スピードをリセット
    score = 0;
    distance = 0;
    speed = 2;
    lives = 3;
    combo = 0;
    if (typeof updateHearts === "function") updateHearts();
    updateLivesDisplay();
    // プレイヤー初期位置に戻す
    currentLane = 1;
    player.style.top = lanes[currentLane] + "px";

    // モーダル閉じる
    document.getElementById("ranking-modal").style.display = "none";

    // ゲーム画面はそのまま見せる
    game.style.display = "block";

    // 背景やBGMをリセット（必要なら）
    bgPos = 0;
    backgroundIndex = 0;
    game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
    bgm.currentTime = 0;
    bgm.playbackRate = 1;
    bgm.volume = 0.1;
    bgm.play().catch(e => console.log("BGM再生失敗", e));

    started = true; // 最初のキー押しなしでBGM鳴らす

    isSpawning = false;
    spawnChallenge(); // 新しい問題スタート！
}

function returnToTitle() {
    // ゲーム画面とモーダルを隠す
    document.getElementById("game").style.display = "none";
    document.getElementById("ranking-modal").style.display = "none";
    
    // タイトル画面を表示
    document.getElementById("title-screen").style.display = "flex";

    // スコア・ライフ・スピードをリセット
    score = 0;
    distance = 0;
    speed = 2;
    lives = 3;
    combo = 0;
    updateHearts();
    updateLivesDisplay();

    // プレイヤー初期位置に戻す
    currentLane = 1;
    player.style.top = lanes[currentLane] + "px";

    // BGM止まってたら再生できるように
    bgPos = 0;
    backgroundIndex = 0;
    game.style.backgroundImage = `url('${backgrounds[backgroundIndex]}')`;
    bgm.pause();
    bgm.currentTime = 0;
    bgm.playbackRate = 1;
    started = false;

    // 🛠️ここ追加！
    isSpawning = false;
}

let combo = 0;
function updateComboBar() {
    const bar = document.getElementById("combo-bar");
    const percentage = Math.min((combo % 10) * 10, 100); // 10コンボで100%
    bar.style.width = `${percentage}%`;
}

// ▼ BGMのフェードアウト処理
function fadeOutBGM() {
    let volume = bgm.volume;
    const fade = setInterval(() => {
        if (volume > 0.01) {
            volume -= 0.01;
            bgm.volume = volume;
        } else {
            clearInterval(fade);
            bgm.pause();
            bgm.currentTime = 0;
        }
    }, 50);
}

</script>
</body>
</html>
